From: Laurent Fousse <laurent@komite.net>
Date: Sat, 28 Apr 2012 13:10:32 -0700
Subject: Apply upstream patch07, fixing the use of very large precisions.

---
 PATCHES                 |    1 +
 VERSION                 |    2 +-
 src/add1.c              |    8 ++++----
 src/add1sp.c            |    2 +-
 src/agm.c               |    4 ++--
 src/eq.c                |    4 ++--
 src/exp.c               |    2 +-
 src/get_d.c             |    2 +-
 src/get_flt.c           |    2 +-
 src/get_str.c           |    6 +++---
 src/init2.c             |    2 +-
 src/lngamma.c           |    2 +-
 src/mpfr-impl.h         |   37 ++++++++++++++++++++++++++-----------
 src/mpfr.h              |    2 +-
 src/mul.c               |   20 ++++++++++----------
 src/pow.c               |    2 +-
 src/print_raw.c         |    4 ++--
 src/round_prec.c        |    4 ++--
 src/round_raw_generic.c |    2 +-
 src/set.c               |    3 +--
 src/set_f.c             |    2 +-
 src/set_prec.c          |    2 +-
 src/setmax.c            |    2 +-
 src/sqr.c               |    8 ++++----
 src/stack_interface.c   |    2 +-
 src/strtofr.c           |    2 +-
 src/sub1sp.c            |    4 ++--
 src/urandomb.c          |   11 +++++++++--
 src/version.c           |    2 +-
 tests/tinits.c          |   27 ++++++++++++++++++++++++++-
 30 files changed, 110 insertions(+), 63 deletions(-)

diff --git a/PATCHES b/PATCHES
index 667f278..8c24f4a 100644
--- a/PATCHES
+++ b/PATCHES
@@ -1,3 +1,4 @@
+large-prec
 logging-varfmt
 logging-freeze
 gmp41compat
diff --git a/VERSION b/VERSION
index ea7c69d..d756a66 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-3.1.0-p6
+3.1.0-p7
diff --git a/src/add1.c b/src/add1.c
index 2e26a60..0935fae 100644
--- a/src/add1.c
+++ b/src/add1.c
@@ -44,12 +44,12 @@ mpfr_add1 (mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd_mode)
   bq = MPFR_PREC(b);
   cq = MPFR_PREC(c);
 
-  an = (aq-1)/GMP_NUMB_BITS+1; /* number of limbs of a */
+  an = MPFR_PREC2LIMBS (aq); /* number of limbs of a */
   aq2 = (mpfr_prec_t) an * GMP_NUMB_BITS;
   sh = aq2 - aq;                  /* non-significant bits in low limb */
 
-  bn = (bq-1)/GMP_NUMB_BITS+1; /* number of limbs of b */
-  cn = (cq-1)/GMP_NUMB_BITS+1; /* number of limbs of c */
+  bn = MPFR_PREC2LIMBS (bq); /* number of limbs of b */
+  cn = MPFR_PREC2LIMBS (cq); /* number of limbs of c */
 
   ap = MPFR_MANT(a);
   bp = MPFR_MANT(b);
@@ -124,7 +124,7 @@ mpfr_add1 (mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd_mode)
       dif = aq2 - diff_exp;
       /* dif is the number of bits of c which overlap with a' */
 
-      difn = (dif-1)/GMP_NUMB_BITS + 1;
+      difn = MPFR_PREC2LIMBS (dif);
       /* only the highest difn limbs from c have to be considered */
       if (MPFR_UNLIKELY(difn > cn))
         {
diff --git a/src/add1sp.c b/src/add1sp.c
index 66c39be..191887d 100644
--- a/src/add1sp.c
+++ b/src/add1sp.c
@@ -107,7 +107,7 @@ mpfr_add1sp (mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd_mode)
 
   /* Read prec and num of limbs */
   p = MPFR_PREC(b);
-  n = (p+GMP_NUMB_BITS-1)/GMP_NUMB_BITS;
+  n = MPFR_PREC2LIMBS (p);
   MPFR_UNSIGNED_MINUS_MODULO(sh, p);
   bx = MPFR_GET_EXP(b);
   d = (mpfr_uexp_t) (bx - MPFR_GET_EXP(c));
diff --git a/src/agm.c b/src/agm.c
index 1f37200..79e2ed8 100644
--- a/src/agm.c
+++ b/src/agm.c
@@ -91,7 +91,7 @@ mpfr_agm (mpfr_ptr r, mpfr_srcptr op2, mpfr_srcptr op1, mpfr_rnd_t rnd_mode)
   q = MPFR_PREC(r);
   p = q + MPFR_INT_CEIL_LOG2(q) + 15;
   MPFR_ASSERTD (p >= 7); /* see algorithms.tex */
-  s = (p - 1) / GMP_NUMB_BITS + 1;
+  s = MPFR_PREC2LIMBS (p);
 
   /* b (op2) and a (op1) are the 2 operands but we want b >= a */
   compare = mpfr_cmp (op1, op2);
@@ -285,7 +285,7 @@ mpfr_agm (mpfr_ptr r, mpfr_srcptr op2, mpfr_srcptr op1, mpfr_rnd_t rnd_mode)
 
       /* Next iteration */
       MPFR_ZIV_NEXT (loop, p);
-      s = (p - 1) / GMP_NUMB_BITS + 1;
+      s = MPFR_PREC2LIMBS (p);
     }
   MPFR_ZIV_FREE (loop);
 
diff --git a/src/eq.c b/src/eq.c
index 0b7b7a3..7921ddd 100644
--- a/src/eq.c
+++ b/src/eq.c
@@ -56,8 +56,8 @@ mpfr_eq (mpfr_srcptr u, mpfr_srcptr v, unsigned long int n_bits)
   if (uexp != vexp)
     return 0; /* no bit agree */
 
-  usize = (MPFR_PREC(u) - 1) / GMP_NUMB_BITS + 1;
-  vsize = (MPFR_PREC(v) - 1) / GMP_NUMB_BITS + 1;
+  usize = MPFR_LIMB_SIZE (u);
+  vsize = MPFR_LIMB_SIZE (v);
 
   if (vsize > usize) /* exchange u and v */
     {
diff --git a/src/exp.c b/src/exp.c
index 2cca955..37f292a 100644
--- a/src/exp.c
+++ b/src/exp.c
@@ -133,7 +133,7 @@ mpfr_exp (mpfr_ptr y, mpfr_srcptr x, mpfr_rnd_t rnd_mode)
               mp_size_t yn;
               int sh;
 
-              yn = 1 + (MPFR_PREC(y) - 1) / GMP_NUMB_BITS;
+              yn = MPFR_LIMB_SIZE (y);
               sh = (mpfr_prec_t) yn * GMP_NUMB_BITS - MPFR_PREC(y);
               MPFR_MANT(y)[0] += MPFR_LIMB_ONE << sh;
               inexact = 1;
diff --git a/src/get_d.c b/src/get_d.c
index fe56d14..0e2e3f9 100644
--- a/src/get_d.c
+++ b/src/get_d.c
@@ -100,7 +100,7 @@ mpfr_get_d (mpfr_srcptr src, mpfr_rnd_t rnd_mode)
           nbits += (1021 + e);
           MPFR_ASSERTD (nbits >= 1);
         }
-      np = (nbits + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+      np = MPFR_PREC2LIMBS (nbits);
       MPFR_ASSERTD ( np <= MPFR_LIMBS_PER_DOUBLE );
       carry = mpfr_round_raw_4 (tp, MPFR_MANT(src), MPFR_PREC(src), negative,
                                 nbits, rnd_mode);
diff --git a/src/get_flt.c b/src/get_flt.c
index 4e2f923..e72cf85 100644
--- a/src/get_flt.c
+++ b/src/get_flt.c
@@ -92,7 +92,7 @@ mpfr_get_flt (mpfr_srcptr src, mpfr_rnd_t rnd_mode)
           nbits += (125 + e);
           MPFR_ASSERTD (nbits >= 1);
         }
-      np = (nbits + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+      np = MPFR_PREC2LIMBS (nbits);
       MPFR_ASSERTD(np <= MPFR_LIMBS_PER_FLT);
       carry = mpfr_round_raw_4 (tp, MPFR_MANT(src), MPFR_PREC(src), negative,
                                 nbits, rnd_mode);
diff --git a/src/get_str.c b/src/get_str.c
index 90cd11d..b460097 100644
--- a/src/get_str.c
+++ b/src/get_str.c
@@ -2351,7 +2351,7 @@ mpfr_get_str (char *s, mpfr_exp_t *e, int b, size_t m, mpfr_srcptr x, mpfr_rnd_t
 
       /* the first digit will contain only r bits */
       prec = (m - 1) * pow2 + r; /* total number of bits */
-      n = (prec - 1) / GMP_NUMB_BITS + 1;
+      n = MPFR_PREC2LIMBS (prec);
 
       MPFR_TMP_MARK (marker);
       x1 = MPFR_TMP_LIMBS_ALLOC (n + 1);
@@ -2417,12 +2417,12 @@ mpfr_get_str (char *s, mpfr_exp_t *e, int b, size_t m, mpfr_srcptr x, mpfr_rnd_t
       exact = 1;
 
       /* number of limbs */
-      n = 1 + (prec - 1) / GMP_NUMB_BITS;
+      n = MPFR_PREC2LIMBS (prec);
 
       /* a will contain the approximation of the mantissa */
       a = MPFR_TMP_LIMBS_ALLOC (n);
 
-      nx = 1 + (MPFR_PREC(x) - 1) / GMP_NUMB_BITS;
+      nx = MPFR_LIMB_SIZE (x);
 
       if ((mpfr_exp_t) m == g) /* final exponent is 0, no multiplication or
                                 division to perform */
diff --git a/src/init2.c b/src/init2.c
index e4329b6..0b2f1ff 100644
--- a/src/init2.c
+++ b/src/init2.c
@@ -51,7 +51,7 @@ mpfr_init2 (mpfr_ptr x, mpfr_prec_t p)
      which both have an odd mantissa */
   MPFR_ASSERTN(p >= MPFR_PREC_MIN && p <= MPFR_PREC_MAX);
 
-  xsize = (mp_size_t) ((p - 1) / GMP_NUMB_BITS) + 1;
+  xsize = MPFR_PREC2LIMBS (p);
   tmp   = (mpfr_limb_ptr) (*__gmp_allocate_func)(MPFR_MALLOC_SIZE(xsize));
 
   MPFR_PREC(x) = p;                /* Set prec */
diff --git a/src/lngamma.c b/src/lngamma.c
index 4831517..de9c770 100644
--- a/src/lngamma.c
+++ b/src/lngamma.c
@@ -67,7 +67,7 @@ unit_bit (mpfr_srcptr (x))
 
   /* Now, the unit bit is represented. */
 
-  prec = ((prec - 1) / GMP_NUMB_BITS + 1) * GMP_NUMB_BITS - expo;
+  prec = MPFR_PREC2LIMBS (prec) * GMP_NUMB_BITS - expo;
   /* number of represented fractional bits (including the trailing 0's) */
 
   x0 = *(MPFR_MANT (x) + prec / GMP_NUMB_BITS);
diff --git a/src/mpfr-impl.h b/src/mpfr-impl.h
index a97f8db..eb64ea6 100644
--- a/src/mpfr-impl.h
+++ b/src/mpfr-impl.h
@@ -646,10 +646,24 @@ union ieee_double_decimal64 { double d; _Decimal64 d64; };
  **************** mpfr_t properties *******************
  ******************************************************/
 
+/* In the following macro, p is usually a mpfr_prec_t, but this macro
+   works with other integer types (without integer overflow). Checking
+   that p >= 1 in debug mode is useful here because this macro can be
+   used on a computed precision (in particular, this formula does not
+   work for a degenerate case p = 0, and could give different results
+   on different platforms). But let us not use an assertion checking
+   in the MPFR_LAST_LIMB() and MPFR_LIMB_SIZE() macros below to avoid
+   too much expansion for assertions (in practice, this should be a
+   problem just when testing MPFR with the --enable-assert configure
+   option and the -ansi -pedantic-errors gcc compiler flags). */
+#define MPFR_PREC2LIMBS(p) \
+  (MPFR_ASSERTD ((p) >= 1), ((p) - 1) / GMP_NUMB_BITS + 1)
+
 #define MPFR_PREC(x)      ((x)->_mpfr_prec)
 #define MPFR_EXP(x)       ((x)->_mpfr_exp)
 #define MPFR_MANT(x)      ((x)->_mpfr_d)
-#define MPFR_LIMB_SIZE(x) ((MPFR_PREC((x))-1)/GMP_NUMB_BITS+1)
+#define MPFR_LAST_LIMB(x) ((MPFR_PREC (x) - 1) / GMP_NUMB_BITS)
+#define MPFR_LIMB_SIZE(x) (MPFR_LAST_LIMB (x) + 1)
 
 
 /******************************************************
@@ -749,7 +763,8 @@ typedef intmax_t mpfr_eexp_t;
 #define MPFR_IS_FP(x)       (!MPFR_IS_NAN(x) && !MPFR_IS_INF(x))
 #define MPFR_IS_SINGULAR(x) (MPFR_EXP(x) <= MPFR_EXP_INF)
 #define MPFR_IS_PURE_FP(x)  (!MPFR_IS_SINGULAR(x) && \
-  (MPFR_ASSERTD (MPFR_MANT(x)[MPFR_LIMB_SIZE(x)-1] & MPFR_LIMB_HIGHBIT), 1))
+  (MPFR_ASSERTD ((MPFR_MANT(x)[MPFR_LAST_LIMB(x)]  \
+                  & MPFR_LIMB_HIGHBIT) != 0), 1))
 
 #define MPFR_ARE_SINGULAR(x,y) \
   (MPFR_UNLIKELY(MPFR_IS_SINGULAR(x)) || MPFR_UNLIKELY(MPFR_IS_SINGULAR(y)))
@@ -1061,7 +1076,7 @@ extern unsigned char *mpfr_stack;
 /* Set a number to 1 (Fast) - It doesn't check if 1 is in the exponent range */
 #define MPFR_SET_ONE(x)                                               \
 do {                                                                  \
-  mp_size_t _size = MPFR_LIMB_SIZE(x) - 1;                            \
+  mp_size_t _size = MPFR_LAST_LIMB(x);                                \
   MPFR_SET_POS(x);                                                    \
   MPFR_EXP(x) = 1;                                                    \
   MPN_ZERO ( MPFR_MANT(x), _size);                                    \
@@ -1213,8 +1228,8 @@ typedef struct {
     _destp = MPFR_MANT (dest);                                              \
     if (MPFR_UNLIKELY (_destprec >= _srcprec))                              \
       {                                                                     \
-        _srcs  = (_srcprec  + GMP_NUMB_BITS-1)/GMP_NUMB_BITS;               \
-        _dests = (_destprec + GMP_NUMB_BITS-1)/GMP_NUMB_BITS - _srcs;       \
+        _srcs  = MPFR_PREC2LIMBS (_srcprec);                                \
+        _dests = MPFR_PREC2LIMBS (_destprec) - _srcs;                       \
         MPN_COPY (_destp + _dests, srcp, _srcs);                            \
         MPN_ZERO (_destp, _dests);                                          \
         inexact = 0;                                                        \
@@ -1227,8 +1242,8 @@ typedef struct {
         mp_limb_t _rb, _sb, _ulp;                                           \
                                                                             \
         /* Compute Position and shift */                                    \
-        _srcs  = (_srcprec  + GMP_NUMB_BITS-1)/GMP_NUMB_BITS;               \
-        _dests = (_destprec + GMP_NUMB_BITS-1)/GMP_NUMB_BITS;               \
+        _srcs  = MPFR_PREC2LIMBS (_srcprec);                                \
+        _dests = MPFR_PREC2LIMBS (_destprec);                               \
         MPFR_UNSIGNED_MINUS_MODULO (_sh, _destprec);                        \
         _sp = (srcp) + _srcs - _dests;                                      \
                                                                             \
@@ -1372,7 +1387,7 @@ typedef struct {
       if (MPFR_LIKELY (MPFR_PREC (dest) == MPFR_PREC (src)))            \
         {                                                               \
           MPN_COPY (MPFR_MANT (dest), MPFR_MANT (src),                  \
-                    (MPFR_PREC (src) + GMP_NUMB_BITS-1)/GMP_NUMB_BITS); \
+                    MPFR_LIMB_SIZE (src));                              \
           inexact = 0;                                                  \
         }                                                               \
       else                                                              \
@@ -1682,7 +1697,7 @@ struct mpfr_group_t {
  MPFR_ASSERTD (_prec >= MPFR_PREC_MIN);                                 \
  if (MPFR_UNLIKELY (_prec > MPFR_PREC_MAX))                             \
    mpfr_abort_prec_max ();                                              \
- _size = (mpfr_prec_t) (_prec + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;     \
+ _size = MPFR_PREC2LIMBS (_prec);                                       \
  if (MPFR_UNLIKELY (_size * (num) > MPFR_GROUP_STATIC_SIZE))            \
    {                                                                    \
      (g).alloc = (num) * _size * sizeof (mp_limb_t);                    \
@@ -1733,7 +1748,7 @@ struct mpfr_group_t {
  MPFR_ASSERTD (_prec >= MPFR_PREC_MIN);                                 \
  if (MPFR_UNLIKELY (_prec > MPFR_PREC_MAX))                             \
    mpfr_abort_prec_max ();                                              \
- _size = (mpfr_prec_t) (_prec + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;     \
+ _size = MPFR_PREC2LIMBS (_prec);                                       \
  (g).alloc = (num) * _size * sizeof (mp_limb_t);                        \
  if (MPFR_LIKELY (_oalloc == 0))                                        \
    (g).mant = (mp_limb_t *) (*__gmp_allocate_func) ((g).alloc);         \
@@ -1886,7 +1901,7 @@ __MPFR_DECLSPEC void mpfr_abort_prec_max _MPFR_PROTO ((void))
        MPFR_NORETURN_ATTR;
 
 __MPFR_DECLSPEC void mpfr_rand_raw _MPFR_PROTO((mpfr_limb_ptr, gmp_randstate_t,
-                                                unsigned long));
+                                                mpfr_prec_t));
 
 __MPFR_DECLSPEC mpz_t* mpfr_bernoulli_internal _MPFR_PROTO((mpz_t*,
                                                             unsigned long));
diff --git a/src/mpfr.h b/src/mpfr.h
index fecb36d..f24f5e2 100644
--- a/src/mpfr.h
+++ b/src/mpfr.h
@@ -27,7 +27,7 @@ http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0-p6"
+#define MPFR_VERSION_STRING "3.1.0-p7"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff --git a/src/mul.c b/src/mul.c
index 184af45..3573d22 100644
--- a/src/mul.c
+++ b/src/mul.c
@@ -93,15 +93,15 @@ mpfr_mul3 (mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd_mode)
 
   ax = MPFR_GET_EXP (b) + MPFR_GET_EXP (c);
 
-  bq = MPFR_PREC(b);
-  cq = MPFR_PREC(c);
+  bq = MPFR_PREC (b);
+  cq = MPFR_PREC (c);
 
-  MPFR_ASSERTD(bq+cq > bq); /* PREC_MAX is /2 so no integer overflow */
+  MPFR_ASSERTN ((mpfr_uprec_t) bq + cq <= MPFR_PREC_MAX);
 
-  bn = (bq+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; /* number of limbs of b */
-  cn = (cq+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; /* number of limbs of c */
+  bn = MPFR_PREC2LIMBS (bq); /* number of limbs of b */
+  cn = MPFR_PREC2LIMBS (cq); /* number of limbs of c */
   k = bn + cn; /* effective nb of limbs used by b*c (= tn or tn+1) below */
-  tn = (bq + cq + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+  tn = MPFR_PREC2LIMBS (bq + cq);
   /* <= k, thus no int overflow */
   MPFR_ASSERTD(tn <= k);
 
@@ -292,12 +292,12 @@ mpfr_mul (mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd_mode)
   bq = MPFR_PREC (b);
   cq = MPFR_PREC (c);
 
-  MPFR_ASSERTD (bq+cq > bq); /* PREC_MAX is /2 so no integer overflow */
+  MPFR_ASSERTN ((mpfr_uprec_t) bq + cq <= MPFR_PREC_MAX);
 
-  bn = (bq+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; /* number of limbs of b */
-  cn = (cq+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; /* number of limbs of c */
+  bn = MPFR_PREC2LIMBS (bq); /* number of limbs of b */
+  cn = MPFR_PREC2LIMBS (cq); /* number of limbs of c */
   k = bn + cn; /* effective nb of limbs used by b*c (= tn or tn+1) below */
-  tn = (bq + cq + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+  tn = MPFR_PREC2LIMBS (bq + cq);
   MPFR_ASSERTD (tn <= k); /* tn <= k, thus no int overflow */
 
   /* Check for no size_t overflow*/
diff --git a/src/pow.c b/src/pow.c
index 983ae4a..40bf652 100644
--- a/src/pow.c
+++ b/src/pow.c
@@ -136,7 +136,7 @@ is_odd (mpfr_srcptr y)
      (b) all the 'z' bits are zero
   */
 
-  prec = ((prec - 1) / GMP_NUMB_BITS + 1) * GMP_NUMB_BITS - expo;
+  prec = MPFR_PREC2LIMBS (prec) * GMP_NUMB_BITS - expo;
   /* number of z+0 bits */
 
   yn = prec / GMP_NUMB_BITS;
diff --git a/src/print_raw.c b/src/print_raw.c
index 12fc0a2..cdd49dc 100644
--- a/src/print_raw.c
+++ b/src/print_raw.c
@@ -84,7 +84,7 @@ mpfr_print_mant_binary(const char *str, const mp_limb_t *p, mpfr_prec_t r)
   int i;
   mpfr_prec_t count = 0;
   char c;
-  mp_size_t n = (r - 1) / GMP_NUMB_BITS + 1;
+  mp_size_t n = MPFR_PREC2LIMBS (r);
 
   printf("%s ", str);
   for(n-- ; n>=0 ; n--)
@@ -109,7 +109,7 @@ mpfr_dump_mant (const mp_limb_t *p, mpfr_prec_t r, mpfr_prec_t precx,
   int i;
   mpfr_prec_t count = 0;
   char c;
-  mp_size_t n = (r - 1) / GMP_NUMB_BITS + 1;
+  mp_size_t n = MPFR_PREC2LIMBS (r);
 
   for(n-- ; n>=0 ; n--)
     {
diff --git a/src/round_prec.c b/src/round_prec.c
index cbc2005..2d045b4 100644
--- a/src/round_prec.c
+++ b/src/round_prec.c
@@ -55,12 +55,12 @@ mpfr_prec_round (mpfr_ptr x, mpfr_prec_t prec, mpfr_rnd_t rnd_mode)
 
   MPFR_ASSERTN(prec >= MPFR_PREC_MIN && prec <= MPFR_PREC_MAX);
 
-  nw = 1 + (prec - 1) / GMP_NUMB_BITS; /* needed allocated limbs */
+  nw = MPFR_PREC2LIMBS (prec); /* needed allocated limbs */
 
   /* check if x has enough allocated space for the significand */
   /* Get the number of limbs from the precision.
      (Compatible with all allocation methods) */
-  ow = (MPFR_PREC (x) + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+  ow = MPFR_LIMB_SIZE (x);
   if (nw > ow)
     {
       /* FIXME: Variable can't be created using custom allocation,
diff --git a/src/round_raw_generic.c b/src/round_raw_generic.c
index c31f28d..9f583e2 100644
--- a/src/round_raw_generic.c
+++ b/src/round_raw_generic.c
@@ -80,7 +80,7 @@ mpfr_round_raw_generic(
       (xprec <= yprec || MPFR_IS_LIKE_RNDZ (rnd_mode, neg)))
     return 0;
 
-  xsize = (xprec-1)/GMP_NUMB_BITS + 1;
+  xsize = MPFR_PREC2LIMBS (xprec);
   nw = yprec / GMP_NUMB_BITS;
   rw = yprec & (GMP_NUMB_BITS - 1);
 
diff --git a/src/set.c b/src/set.c
index 7bbe1d1..56189cc 100644
--- a/src/set.c
+++ b/src/set.c
@@ -48,8 +48,7 @@ mpfr_set4 (mpfr_ptr a, mpfr_srcptr b, mpfr_rnd_t rnd_mode, int signb)
       /* Same precision and b is not singular:
        * just copy the mantissa, and set the exponent and the sign
        * The result is exact. */
-      MPN_COPY (MPFR_MANT (a), MPFR_MANT (b),
-                (MPFR_PREC (b) + GMP_NUMB_BITS-1)/GMP_NUMB_BITS);
+      MPN_COPY (MPFR_MANT (a), MPFR_MANT (b), MPFR_LIMB_SIZE (b));
       MPFR_RET (0);
     }
   else
diff --git a/src/set_f.c b/src/set_f.c
index 2755964..ef8251e 100644
--- a/src/set_f.c
+++ b/src/set_f.c
@@ -43,7 +43,7 @@ mpfr_set_f (mpfr_ptr y, mpf_srcptr x, mpfr_rnd_t rnd_mode)
   if (SIZ(x) * MPFR_FROM_SIGN_TO_INT(MPFR_SIGN(y)) < 0)
     MPFR_CHANGE_SIGN (y);
 
-  sy = 1 + (MPFR_PREC(y) - 1) / GMP_NUMB_BITS;
+  sy = MPFR_LIMB_SIZE (y);
   my = MPFR_MANT(y);
   mx = PTR(x);
 
diff --git a/src/set_prec.c b/src/set_prec.c
index ede9b25..4c7222b 100644
--- a/src/set_prec.c
+++ b/src/set_prec.c
@@ -32,7 +32,7 @@ mpfr_set_prec (mpfr_ptr x, mpfr_prec_t p)
   MPFR_ASSERTN (p >= MPFR_PREC_MIN && p <= MPFR_PREC_MAX);
 
   /* Calculate the new number of limbs */
-  xsize = (p - 1) / GMP_NUMB_BITS + 1;
+  xsize = MPFR_PREC2LIMBS (p);
 
   /* Realloc only if the new size is greater than the old */
   xoldsize = MPFR_GET_ALLOC_SIZE (x);
diff --git a/src/setmax.c b/src/setmax.c
index 0ac4e16..7dbd574 100644
--- a/src/setmax.c
+++ b/src/setmax.c
@@ -32,7 +32,7 @@ mpfr_setmax (mpfr_ptr x, mpfr_exp_t e)
   mp_limb_t *xp;
 
   MPFR_SET_EXP (x, e);
-  xn = 1 + (MPFR_PREC(x) - 1) / GMP_NUMB_BITS;
+  xn = MPFR_LIMB_SIZE (x);
   sh = (mpfr_prec_t) xn * GMP_NUMB_BITS - MPFR_PREC(x);
   xp = MPFR_MANT(x);
   xp[0] = MP_LIMB_T_MAX << sh;
diff --git a/src/sqr.c b/src/sqr.c
index e9916da..f94e7db 100644
--- a/src/sqr.c
+++ b/src/sqr.c
@@ -56,11 +56,11 @@ mpfr_sqr (mpfr_ptr a, mpfr_srcptr b, mpfr_rnd_t rnd_mode)
   ax = 2 * MPFR_GET_EXP (b);
   bq = MPFR_PREC(b);
 
-  MPFR_ASSERTD (2 * bq > bq); /* PREC_MAX is /2 so no integer overflow */
+  MPFR_ASSERTN (2 * (mpfr_uprec_t) bq <= MPFR_PREC_MAX);
 
-  bn = MPFR_LIMB_SIZE(b); /* number of limbs of b */
-  tn = 1 + (2 * bq - 1) / GMP_NUMB_BITS; /* number of limbs of square,
-                                               2*bn or 2*bn-1 */
+  bn = MPFR_LIMB_SIZE (b); /* number of limbs of b */
+  tn = MPFR_PREC2LIMBS (2 * bq); /* number of limbs of square,
+                                    2*bn or 2*bn-1 */
 
   if (MPFR_UNLIKELY(bn > MPFR_SQR_THRESHOLD))
     return mpfr_mul (a, b, b, rnd_mode);
diff --git a/src/stack_interface.c b/src/stack_interface.c
index 92673e8..8e812d7 100644
--- a/src/stack_interface.c
+++ b/src/stack_interface.c
@@ -26,7 +26,7 @@ http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 size_t
 mpfr_custom_get_size (mpfr_prec_t prec)
 {
-  return (prec + GMP_NUMB_BITS -1) / GMP_NUMB_BITS * BYTES_PER_MP_LIMB;
+  return MPFR_PREC2LIMBS (prec) * BYTES_PER_MP_LIMB;
 }
 
 #undef mpfr_custom_init
diff --git a/src/strtofr.c b/src/strtofr.c
index dda5740..7036662 100644
--- a/src/strtofr.c
+++ b/src/strtofr.c
@@ -467,7 +467,7 @@ parsed_string_to_mpfr (mpfr_t x, struct parsed_string *pstr, mpfr_rnd_t rnd)
       /* Set y to the value of the ~prec most significant bits of pstr->mant
          (as long as we guarantee correct rounding, we don't need to get
          exactly prec bits). */
-      ysize = (prec - 1) / GMP_NUMB_BITS + 1;
+      ysize = MPFR_PREC2LIMBS (prec);
       /* prec bits corresponds to ysize limbs */
       ysize_bits = ysize * GMP_NUMB_BITS;
       /* and to ysize_bits >= prec > MPFR_PREC (x) bits */
diff --git a/src/sub1sp.c b/src/sub1sp.c
index 48bdda8..0b90a5e 100644
--- a/src/sub1sp.c
+++ b/src/sub1sp.c
@@ -155,8 +155,8 @@ mpfr_sub1sp (mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd_mode)
   MPFR_ASSERTD(MPFR_IS_PURE_FP(c));
 
   /* Read prec and num of limbs */
-  p = MPFR_PREC(b);
-  n = (p-1)/GMP_NUMB_BITS+1;
+  p = MPFR_PREC (b);
+  n = MPFR_PREC2LIMBS (p);
 
   /* Fast cmp of |b| and |c|*/
   bx = MPFR_GET_EXP (b);
diff --git a/src/urandomb.c b/src/urandomb.c
index 15c38d1..4039415 100644
--- a/src/urandomb.c
+++ b/src/urandomb.c
@@ -31,13 +31,20 @@ http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
    a sufficient number of limbs */
 void
 mpfr_rand_raw (mpfr_limb_ptr mp, gmp_randstate_t rstate,
-               unsigned long int nbits)
+               mpfr_prec_t nbits)
 {
   mpz_t z;
 
+  MPFR_ASSERTN (nbits >= 1);
   /* To be sure to avoid the potential allocation of mpz_urandomb */
-  ALLOC(z) = SIZ(z) = ((nbits - 1) / GMP_NUMB_BITS) + 1;
+  ALLOC(z) = SIZ(z) = MPFR_PREC2LIMBS (nbits);
   PTR(z)   = mp;
+#if __MPFR_GMP(5,0,0)
+  /* Check for integer overflow (unless mp_bitcnt_t is signed,
+     but according to the GMP manual, this shouldn't happen).
+     Note: mp_bitcnt_t has been introduced in GMP 5.0.0. */
+  MPFR_ASSERTN ((mp_bitcnt_t) -1 < 0 || nbits <= (mp_bitcnt_t) -1);
+#endif
   mpz_urandomb (z, rstate, nbits);
 }
 
diff --git a/src/version.c b/src/version.c
index b44ceb1..5d8bbea 100644
--- a/src/version.c
+++ b/src/version.c
@@ -25,5 +25,5 @@ http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0-p6";
+  return "3.1.0-p7";
 }
diff --git a/tests/tinits.c b/tests/tinits.c
index d35fd56..6c84a2e 100644
--- a/tests/tinits.c
+++ b/tests/tinits.c
@@ -1,4 +1,4 @@
-/* Test file for mpfr_inits, mpfr_inits2 and mpfr_clears.
+/* Test file for mpfr_init2, mpfr_inits, mpfr_inits2 and mpfr_clears.
 
 Copyright 2003, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
 Contributed by the Arenaire and Caramel projects, INRIA.
@@ -20,18 +20,43 @@ along with the GNU MPFR Library; see the file COPYING.LESSER.  If not, see
 http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA. */
 
+#include <stdlib.h>
+
 #include "mpfr-test.h"
 
 int
 main (void)
 {
   mpfr_t a, b, c;
+  long large_prec;
 
   tests_start_mpfr ();
+
   mpfr_inits (a, b, c, (mpfr_ptr) 0);
   mpfr_clears (a, b, c, (mpfr_ptr) 0);
   mpfr_inits2 (200, a, b, c, (mpfr_ptr) 0);
   mpfr_clears (a, b, c, (mpfr_ptr) 0);
+
+  /* test for precision 2^31-1, see
+     https://gforge.inria.fr/tracker/index.php?func=detail&aid=13918 */
+  large_prec = 2147483647;
+  if (getenv ("MPFR_CHECK_LARGEMEM") != NULL)
+    {
+      /* We assume that the precision won't be increased internally. */
+      if (large_prec > MPFR_PREC_MAX)
+        large_prec = MPFR_PREC_MAX;
+      mpfr_inits2 (large_prec, a, b, (mpfr_ptr) 0);
+      mpfr_set_ui (a, 17, MPFR_RNDN);
+      mpfr_set (b, a, MPFR_RNDN);
+      if (mpfr_get_ui (a, MPFR_RNDN) != 17)
+        {
+          printf ("Error in mpfr_init2 with precision 2^31-1\n");
+          exit (1);
+        }
+      mpfr_clears (a, b, (mpfr_ptr) 0);
+    }
+
   tests_end_mpfr ();
+
   return 0;
 }
